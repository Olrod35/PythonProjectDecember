#Множества - неупорядоченная уникальная последовтельность
# элементов - неизменяемые данные
#a = set()
#a = {1, 2, 3, 4}
#b = {} - #это уже словарь

#a = [1, 2, 3]
#set(a) #преобразовали в множество
#Множество не может хранить другое множество

#У неизменяемых данных есть хэш табл
"""from pprint import pprint #pretty print
a = 1
pprint(dir(a))
#b = 'gkjkl'
#pprint(b._hash_())
#тип данных, который имеет хэш, может быть элементом множества
# или ключом к словарю

#МНожество работает так же быстро, как и tuple
#Хорошо работает с временным преобразованием типов данных(вхождение эл-тов в список ..)

a = {1, 2, 4, 8}
b = {'a', 'a', 1}
b.add('n')
print(b)
#a[1] индекс не поддерживается, т.е. циклом проходим неупорядоченно
print(len(b))
b.remove(1)
b.discard(1)
#a.union(b) - для объединения должна быть 3я переменная, иначе просто в память сохраняется
c = a | b #пересечение или объединение 2х множеств
a.intersection(b) - #показывает общие элементы для 2х ножеств
a.difference(b)
a.symmetric_difference(b) #общее выкинуто, осталось только разное
a.issuperset(b) #является ли b подмножеством у a (a - superset)
b.issubset(a)
a.isdisjoint(b) """
a = {i for i in range(10) if i//2 == 0}
b = {i for i in range(10) if i%2 == 0}
print(a)
print(b)

m = 'fdddddddddd'.join([i for i in set('asdfg')])
print(m)

a = frozenset([]) # если хотим , чтоб в список больше ничего не добавили
#например, список преобразуем в множество и нельзя использовать add